%
% Portuguese-BR vertion
% 
\documentclass{report}

\usepackage{ipprocess}
% Use longtable if you want big tables to split over multiple pages.
\usepackage{longtable}
\usepackage{tikz}
\usepackage[utf8]{inputenc} 
\usepackage[portuguese]{babel} % Uncomment for portuguese
\usepackage{siunitx}
\usepackage{pdflscape}
\usepackage{verbatim}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}


\sloppy

\graphicspath{{./pictures/}} % Pictures dir
\makeindex
\begin{document}

\DocumentTitle{Documento de Arquitetura}
\Project{\si\micro Risc}
\Organization{}
\Version{Build 1.0}

\capa
\newpage
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Revision History
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{\center Histórico de Revisões}
\begin{center}
\begin{longtable}[pos]{|m{50pt} | m{200pt} | m{100pt}|} \hline
	\cellcolor[gray]{0.9} \textbf{Data} & \cellcolor[gray]{0.9}\textbf{Descrição} & \cellcolor[gray]{0.9}\textbf{Autor(s)}\\ \hline \endfirsthead \hline
	\multicolumn{2}{|c|}{{\bfseries \textbf{continuação da tabela anterior}}} \\ \hline
	\textbf{Data} & \cellcolor[gray]{0.9}\textbf{Descrição} & \cellcolor[gray]{0.9}\textbf{Autor(s)}\\ \hline
	\multicolumn{2}{|c|}{{\textbf{continua na próxima página}}} \\ \hline \endfoot
	\hline \endlastfoot
	
  14/12/2015 &  Estruturação do documento &  Patricia Gomes\\ \hline  
  19/12/2015 &  Adição dos datapath's por instrução &  Fábio Barros\\ \hline 
  19/12/2015 &  Correção das tabelas &  Matheus Borges\\ \hline 
  19/12/2015 &  Criação do capítulo Assembly & Matheus Borges\\ \hline 
  19/12/2015 &  Criação das tabelas de entrada e saída dos módulos &  Patricia Gomes\\ \hline 
  19/12/2015 &  Preenchimento da tabela Acrônimos e Abreviações &  Matheus Borges\\ \hline
  19/12/2015 &  Preenchimento da tabela da tabela de sinais da unidade de controle &  Fábio Barros\\ \hline 
  19/12/2015 &  Criação do capítulo Requisitos do Processador  & Patricia Gomes \\ \hline 
  20/12/2015 &  Finalização do documento & Fábio Barros, Matheus Borges e Patricia Gomes\\ \hline
  20/12/2015 &  Revisão do documento & Fábio Barros e Matheus Borges \\ \hline
  15/01/2016 &  Alterações no documento & Patricia Gomes \\ \hline 
  29/01/2016 &  Correções do documento & Patricia Gomes \\ \hline 
  30/01/2016 &  Revisão das tabelas de instruções & Matheus Borges \\ \hline 
  31/01/2016 &  Revisão da formatação do documento & Matheus Borges \\ \hline
  08/04/2016 &  Alterações dos datapath para pipeline & Matheus Borges \\ \hline
  11/04/2016 &  Alterações das descrições dos módulos para pipeline & Fábio Barros\\ \hline
  11/04/2016 &  Revisão das descrições de funcionamento & Matheus Borges\\ \hline
  

\end{longtable}
\end{center}
\newpage
\tableofcontents
\newpage
\section{Introdução}
\subsection{Objetivo} 
O processador pode ser definido como o cérebro do computador, é ele o responsável por realizar todas as instruções dentro do computador como operações de lógicas e cálculos. Além disso ele é responsável pela tomada de decisões do sistema.

O objetivo deste documento de arquitetura é definir as especificações do processador desenvolvido. O documento de arquitetura é importante por permitir que outras pessoas possam utilizá-lo para construir um sistema com sucesso a partir dele. O mesmo  define os parâmetros de implementação que compõem os requisitos do processador implementado, tais requisitos incluem a arquitetura do conjunto de instruções, definições de entrada e saída e a arquitetura geral do processador. 

\subsection{Organização do Documento} 
\textbf{Sessão 2:} Apresenta uma definição de requisitos funcionais e não funcionais. \newline
\textbf{Sessão 3:} Apresenta a visão geral da arquitetura. \newline
\textbf{Sessão 4:} Especifica o conjunto de instruções do processador. \newline
\textbf{Sessão 5:} Especifica os elementos que compõem o sistema.\newline
\textbf{Sessão 6:} Descreve o montador. \newline

% inicio da tabela de acronimos e abreviacoes do documento
\subsection{Acrônimos e Abreviações}

\begin{center}
\begin{longtable}[pos]{|m{52pt} | m{350pt}|} \hline
	\cellcolor[gray]{0.9} \textbf{Sigla} & \cellcolor[gray]{0.9}\textbf{Descrição}\\ \hline \endfirsthead \hline
	\multicolumn{2}{|c|}{{\bfseries \textbf{continuação da tabela anterior}}} \\ \hline
	\cellcolor[gray]{0.9} \textbf{Sigla} & \cellcolor[gray]{0.9}\textbf{Descrição}\\ \hline \endhead
	\multicolumn{2}{|c|}{{\textbf{continua na próxima página}}} \\ \hline \endfoot
	\hline \endlastfoot
	
	GPR     & Registrador de Propósito Geral\\ \hline
    ISA     & Instruction Set Architecture - Conjunto de Instruções da Arquitetura\\ \hline
    IF      & Instruction Fetch - Busca da Instrução  \\ \hline
    ID      & Instruction Decode - Decoficação da Instrução \\ \hline
    RF      & Register Fetch -  Acesso aos Registradores\\ \hline
    EX      & Execute - Execução da Instrução\\ \hline
    MEM     & Memory - Acesso à Memória\\ \hline
    WB      & Write Back - Escrita de volta\\ \hline
    OP      & Operation Code - Código da Operação\\ \hline
    RA      & Read A - Ler A\\ \hline
    RB      & Read B - Ler B\\ \hline
    WC      & Write C - Escreve C\\ \hline
    COND    & Condição\\ \hline
    Const16 & Constante de 16 bits \\ \hline
    IM     & Instruction Memory (Memória de Instruções)\\ \hline
	PC     & Program Counter (Contador de Programa)\\ \hline
	RB     & Register Bank (Banco de Registradores)\\ \hline
	SG     & Signal Generator (Gerador de Sinal)\\ \hline
	ALU    & Arithmetic Logic Unit (Unidade Lógica Aritmética)\\ \hline
	RF     & Register Flag (Registrador de Flags)\\ \hline
	TF     & Tests Flag (Testador de Flags)\\ \hline
	MX     & Multiplexer (Multiplexador)\\ \hline
	DM     & Data Memory (Memória de Dados)\\ \hline
	SE     & Signal Extender (Extensor de Sinal)\\ \hline
	FU     & Forward Unit (Unidade de encaminhamento)\\ \hline
	RISC   & Reduced Instruction Set Computer (Computador com um Conjunto Reduzido de Instruções)\\ \hline

\caption{Tabela de acrônimos e abreviações}
\end{longtable}
\end{center}

\begin{comment}
\section{Requisitos do Processador}
É requerido que o processador desenvolvido seja capaz de executar instruções que possibilitem gerenciar a máquina de forma extremamente rápida e eficiente.\newline

A estrutura dos requisitos funcionais e não funcionais é descrita ao longo deste documento. Sendo requisito funcional e não funcional definidos na tabela abaixo:

% inicio da tabela
\FloatBarrier
\begin{table}[H]
    \begin{center}
        \begin{tabular}[pos]{|>{\arraybackslash}m{100pt}|>{\arraybackslash}m{290pt}|} 
          \hline
          \cellcolor[gray]{0.9}\textbf{Termos} & \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
            Requisito Funcional   & Requisitos de hardware que compõem os módulos, descrevendo as ações que o mesmo deve estar apto a executar. \\ \hline
            Requisito Não Funcional   & Requisitos de hardware que compõem os módulos, representando as características que o mesmo deve ter, ou restrições que  o mesmo deve operar. \\ \hline
        \end{tabular}
        \caption{Tabela de Definição}
    \end{center}
\end{table}  

Os requisitos funcionais e não-funcionais são listados nas tabelas abaixo respectivamente:

% inicio da tabela
\FloatBarrier
\begin{table}[H]
    \begin{center}
        \begin{tabular}[pos]{|>{\arraybackslash}m{100pt}|>{\arraybackslash}m{290pt}|} 
          \hline
          \cellcolor[gray]{0.9}\textbf{Requisitos Funcionais} & \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
           ISA composta por 42 instruções.  &  O processador deve ser capaz de executar 42 instruções.  \\ \hline
        \end{tabular}
        \caption{Tabela de Requisitos Funcionais}
    \end{center}
\end{table}  

% inicio da tabela
\FloatBarrier
\begin{table}[H]
    \begin{center}
        \begin{tabular}[pos]{|>{\arraybackslash}m{100pt}|>{\arraybackslash}m{290pt}|} 
          \hline
          \cellcolor[gray]{0.9}\textbf{Requisitos Não-Funcionais} & \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
           Possuir 16 GPR de 32 bits de largura   & O processador deve possuir 15 registradores de propósito geral, sendo que cada registrador deve ser capaz de armazenar uma palavra de 32 bits. \\ \hline
           Arquitetura de 32 bits   & O processador deve suportar operações com operandos que possuam 32 bits. \\ \hline
        \end{tabular}
        \caption{Tabela de Requisitos Não-Funcionais}
    \end{center}
\end{table}  

Os requisitos foram atendidos, de forma que as instruções, apresentadas nas sessões seguintes, foram sugeridas a partir dos documentos de testes que foi entregue pelos solicitantes. A operação que cada instrução realiza é descrita ao lado da instrução. 
\end{comment}
\newpage
\section{Visão Geral da Arquitetura}
Este documento descreve um processador µRISC adaptado à 32 bits. Esse processador possui 16 registradores de propósito geral e é composto por um conjunto de 42 instruções. 

Cada instrução necessita de três ciclos de clock para serem finalizadas. Porém, devido a arquitetura ser baseada no princípio de pipeline, o processador consegue executar três instruções simultaneamente. Com isso, esta arquitetura possui o valor 1 como média de instruções por ciclo.
A arquitetura foi dividida em 3 estágios, são eles: IF/ID/RF, EX/MEM e WB, apresentados na Figura 1. No primeiro estágio,  a próxima instrução a ser executada, definida pelo contador de programa (PC), é lida da memória de instruções (IM), decodificada e os operandos são lidos do banco de registradores ou, em caso de operações com constantes, manipulados pelo extensor de sinal (SE). Ainda no primeiro estágio são tratados os desvios do fluxo de execução, quando as operações forem deste tipo. No segundo estágio, a instrução é executa pela unidade lógica aritmética (ALU) ou pela memória, em caso de operações de armazenamento ou leitura em memória. No terceiro e último estágio (WB) os resultados são escritos no banco de registradores (quando se aplicar).

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./pictures/Datapath.pdf}
\caption{Datapath Geral}
\end{figure}

OBS: O banco de registradores (RB) presente no último estágio é uma representação do mesmo presente no primeiro, utilizado apenas para facilitar a visualização e compreensão do caminho dos dados.
\newpage
\subsection{Principais características}
\begin{itemize}
    \item \textbf {Arquitetura de 32 bits;}
    \item \textbf {16 GPR de 32 bits de largura (r0 ... r15);}
    \item \textbf {ISA composta por 42 instruções;}
    \item \textbf {Instruções de até 3 operandos;}
    \item \textbf {Unidade de controle (Gerador de Sinais) hardwired;}
    \item \textbf {Funcionamento em pipeline com três estágios}
    \item \textbf {Detecção e tratamento de conflito de dados;}
    \item \textbf {Execução de três instruções por ciclo de clock;}
    \item \textbf {Sem atrasos devido a conflitos;}
    \item \textbf {Armazenamento em memória de forma big-endian;}
    \item \textbf {Endereçamento por registrador e imediato;}
    \item \textbf {Montador desenvolvido na linguagem C;}
    \item \textbf {Processador descrito utilizando a linguagem Verilog.}
\end{itemize}

\section{Arquitetura das Instruções}
O conjunto de instruções do processador foi dividido nos seguintes grupos:\newline
\begin{itemize}
    \item \textbf {Instruções lógicas e aritméticas;}
    \item \textbf {Instruções com constante;}
    \item \textbf {Instruções de acesso à memória;}
    \item \textbf {Instruções de desvio;}
    \item \textbf {Instruções de desvio por registrador;}
    \item \textbf {NOP;}
    \item \textbf {HALT;}
\end{itemize}

\newpage
\subsection{Instruções Lógicas e Aritméticas}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./pictures/DatapathLA.pdf}
\caption{Datapath de Lógicas Aritméticas}
\end{figure}


A Figura 2 apresenta o caminho de dados específico de instruções lógicas e aritméticas, nela é possível observar quais elementos participam da realização destas operações.\newline

Os elementos que caracterizam esse tipo de instrução são: 
\begin{itemize}
    \item Unidade logica aritmética (ALU): responsável por realiza a operação gerar e armazenar os sinais de flags;
\end{itemize}
 

As instruções de lógica e aritmética possuem o seguinte formato:
% inicio da tabela de formato de instruções de lógica e aritmética
\FloatBarrier
\begin{table}[H]
    \begin{center}
    \renewcommand{\arraystretch}{1.5}
        \begin{tabular}[pos]{|>{\centering\arraybackslash}m{33pt}|>{\centering\arraybackslash}m{55pt}|>{\centering\arraybackslash}m{44pt}|>{\centering\arraybackslash}m{44pt}|>{\centering\arraybackslash}m{44pt}|>{\centering\arraybackslash}m{132pt}|} 
          \hline
          \cellcolor[gray]{0.9}\textbf{31:29} & \cellcolor[gray]{0.9}\textbf{28:24} & \cellcolor[gray]{0.9}\textbf{23:20} & \cellcolor[gray]{0.9}\textbf{19:16} & \cellcolor[gray]{0.9}\textbf{15:12} & \cellcolor[gray]{0.9}\textbf{11:0} \\ \hline
            0 0 1   & OP\_ALU    & WC    & RA    & RB    &   X X X X X X X X X X X X \\ \hline
        \end{tabular}
        \caption{Tabela de Formato}
    \end{center}
\end{table}  
% fim

\newpage

% inicio da tabela de operações das instruções de lógica e aritmética
\begin{center}
\begin{longtable}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\raggedright\arraybackslash}m{80pt}|>{\raggedright\arraybackslash}m{147pt}|>{\raggedleft\arraybackslash}m{100pt}|} \hline
	\cellcolor[gray]{0.9}\textbf{OP\_ALU} & \centering \cellcolor[gray]{0.9}\textbf{Mnemônico} & \centering \cellcolor[gray]{0.9}\textbf{Operação} & \centering \cellcolor[gray]{0.9}\textbf{Flags Atualizadas}\tabularnewline \hline \endfirsthead \hline
	\multicolumn{4}{|c|}{{\bfseries \textbf{continuação da tabela anterior}}} \\ \hline
	\cellcolor[gray]{0.9}\textbf{OPALU} & \centering \cellcolor[gray]{0.9}\textbf{Mnemônico} & \centering \cellcolor[gray]{0.9}\textbf{Operação} & \centering \cellcolor[gray]{0.9}\textbf{Flags Atualizadas}\tabularnewline \hline \endhead
	\multicolumn{4}{|c|}{{\textbf{continua na próxima página}}} \\ \hline \endfoot
	\hline \endlastfoot
        00000   & add c,a,b         & C = A + B                             & O S C Z \\ \hline
        00001   & addinc c,a,b      & C = A + B + 1                         & O S C Z \\ \hline
        00011   & inca c,a          & C = A + 1                             & O S C Z \\ \hline
        00100   & subdec c,a,b      & C = A – B – 1                         & O S C Z \\ \hline
        00101   & sub c, a, b       & C = A – B                             & O S C Z \\ \hline
        00110   & deca c, a         & C = A – 1                             & O S C Z \\ \hline
        01000   & lsl c, a          &  C = Deslocamento Lógico Esq. (A)     & S C Z \\ \hline
        01001   & asr c, a          & C = Deslocamento Aritmético Dir. (A)  & S C Z \\ \hline
        10000   & zeros c           & C = 0                                 & Z \\ \hline
        10001   & and c, a, b       & C = A\&B                              & S\ \ \ \ Z \\ \hline
        10010   & andnota c,a,b     & C = !A\&B                             & S\ \ \ \ Z \\ \hline
        10011   & passb c, b        & C = B                                 & \\ \hline
        10100   & andnotb c, a, b   & C = A\&!B                             & S\ \ \ \ Z \\ \hline
        10101   & passa, c, a       & C = A                                 & S\ \ \ \ Z \\ \hline
        10110   & xor c, a, b       & C = A\^{}B                            & S\ \ \ \ Z \\ \hline
        10111   & or c, a, b        & C = A | B                             & S\ \ \ \ Z \\ \hline
        11000   & nand c, a, b      & C = !A\&!B                            & S\ \ \ \ Z \\ \hline
        11001   & xnor c, a, b      & C = !(A\^{}B)                         & S\ \ \ \ Z \\ \hline
        11010   & passnota c, a     & C = !A                                & S\ \ \ \ Z \\ \hline
        11011   & ornota c, a, b    & C = !A|B                              & S\ \ \ \ Z \\ \hline
        11100   & passnotb c, b     & C = !B                                & S\ \ \ \ Z \\ \hline
        11101   & ornotb c, a, b    & C = A|!B                              & S\ \ \ \ Z \\ \hline
        11110   & nor c, a, b       & C = !A|!B                             & S\ \ \ \ Z \\ \hline
        11111   & ones c            & C = 1                                 & \\ \hline

\end{longtable}
\end{center}
\subsection{Instruções com Constante}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./pictures/DatapathCONS.pdf}
\caption{Datapath de Constantes}
\end{figure}
A Figura 3 apresenta o caminho de dados específico de instruções com constantes, nela é possível observar quais elementos participam da realização destas operações.\newline

O elemento que caracteriza esse tipo de instrução é o extensor de sinal responsável por transformar uma constante de 16 ou 12 bits em 32 bits. O nível lógico do sinal OP\_SE define se a constante a ser extendida é de tamanho 12 bits no caso de operações de jump ou 16 bits no caso de operações com constante. Assim é garantido que o restante dos bits não tenha informações erradas que irão ser operadas na unidade lógica e aritimetica (ALU).

% inicio da tabela de formato de instruções com constante
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.2}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{35pt}|>{\centering\arraybackslash}m{57pt}|>{\centering\arraybackslash}m{46pt}|>{\centering\arraybackslash}m{46pt}|>{\centering\arraybackslash}m{180pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{31:29} & \cellcolor[gray]{0.9}\textbf{28:24} & \cellcolor[gray]{0.9}\textbf{23:20} & \cellcolor[gray]{0.9}\textbf{19:16} & \cellcolor[gray]{0.9}\textbf{15:0} \\ \hline
        0 1 0       & OP\_ALU        & WC        & X X X X      & CONSTANTE \\ \hline
    \end{tabular}
    \caption{Tabela de Formato}
  \end{center}
\end{table}  
% fim

% inicio da tabela de operações das instruções com constante
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.2}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{80pt}|>{\centering\arraybackslash}m{120pt}|>{\centering\arraybackslash}m{189pt}|} 
      \hline
      \cellcolor[gray]{0.9}\textbf{OP\_ALU} & \cellcolor[gray]{0.9}\textbf{Mnemônico} & \cellcolor[gray]{0.9}\textbf{Operação} \\ \hline
        01100      & loadlit c, Const16        & C = CONSTANTE \\ \hline
        01101      & lcl c, Const16            & C = Const16|(C\&0xffff0000) \\ \hline
        01110      & lch c, Const16            & C = (Const16 « 16)|(C\&0x0000ffff ) \\ \hline
    \end{tabular}
    \caption{Tabela de Instruções com Constante}
  \end{center}
\end{table}  
% fim

\subsection{Instruções de Acesso à Memória}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./pictures/DatapathMEM.pdf}
\caption{Datapath Memória}
\end{figure}
As instruções de acesso à memória são Load e Store. Na instrução Load o endereço presente no registrador B é lido da memória, e a saída é escrita no banco de registradores no endereço especificado na pelo registrador WC. Na instrução Store os dados são lidos do banco de registradores e escritos na memória, sendo registrador A o dado a ser escrito e o registrador B o endereço onde será armazenado. 
A memória de dados realiza a leitura constantemente. Já a escrita apenas é realizada quando o sinal W\_DM é mandado em nível lógico alto.
As instruções de acesso à memória possuem o seguinte formato:
% inicio da tabela de formato de instruções de acesso à memória
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.2}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{30pt}|>{\centering\arraybackslash}m{42pt}|>{\centering\arraybackslash}m{42pt}|>{\centering\arraybackslash}m{35pt}|>{\centering\arraybackslash}m{35pt}|>{\centering\arraybackslash}m{35pt}|>{\centering\arraybackslash}m{121pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{31:29} & 
      \cellcolor[gray]{0.9}\textbf{28:25} & 
      \cellcolor[gray]{0.9}\textbf{24} & 
      \cellcolor[gray]{0.9}\textbf{23:20} & 
      \cellcolor[gray]{0.9}\textbf{19:16} & 
      \cellcolor[gray]{0.9}\textbf{15:12} & 
      \cellcolor[gray]{0.9}\textbf{11:0} \\ \hline
      1 0 0         & X X X X &W\_DM & WC        & RA        & RB        & X X X X X X X X X X X X \\ \hline
    \end{tabular}
    \caption{Tabela de Formato}
    \end{center}
\end{table}  
% fim

% inicio da tabela de operações das instruções de acesso à memória
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.2}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{79pt}|>{\centering\arraybackslash}m{150pt}|>{\centering\arraybackslash}m{160pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{W\_DM} & \cellcolor[gray]{0.9}\textbf{Mnemônico} & \cellcolor[gray]{0.9}\textbf{Operação} \\ \hline
        X       & load c, b         & C = Mem[B] \\ \hline
        1       & store b, a        & Mem[B] = A \\ \hline
    \end{tabular}
    \caption{Tabela de Instruções de Acesso à Memória}
  \end{center}
\end{table}  
% fim


\subsection{Instruções de Desvio}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./pictures/DatapathDES.pdf}
\caption{Datapath Desvio Condicional}
\end{figure}

O módulo que caracteriza essa instrução é o testador de flags (TF) que, a partir de uma condição, determina qual será o próximo valor do PC. Este valor pode ser o PC + 1 (fluxo normal), a saída do SE (instruções jf, jt e j) ou a saída PRB do banco de registradores (instruções jal e jr, especificados na sessão 4.5)

As instruções de desvio condicional e incondicional realizam um salto para um endereço absoluto da memória de instruções, informado pelo campo DESTINO (demonstrado na Tabela de Formato). Este endereçamento pode ser de até 2\^{}12 bits. Em caso de endereços maior que 12 bits, deve-se utilizar as instruções lcl e lch para carregar o endereço do Label de destino em um registrador. Em seguida, deve-se realizar um desvio por registrador (especificado na sessão 4.5), utilizando como parâmetro este registrador. Esta decisão de utilziar endereçamento absoluto retira da ALU a responsabilidade de calcular o novo destino.

Tais instruções possuem o formato descrito abaixo na tabela:
% inicio da tabela de formato de instruções de desvio
\FloatBarrier
\begin{table}[H]
  \begin{center}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{33pt}|>{\centering\arraybackslash}m{28pt}|>{\centering\arraybackslash}m{33pt}|>{\centering\arraybackslash}m{105pt}|>{\centering\arraybackslash}m{33pt}|>{\centering\arraybackslash}m{120pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{31:29} & \cellcolor[gray]{0.9}\textbf{28:27} & \cellcolor[gray]{0.9}\textbf{26:24} & \cellcolor[gray]{0.9}\textbf{23:15} & \cellcolor[gray]{0.9}\textbf{14:12} & \cellcolor[gray]{0.9}\textbf{11:0} \\ \hline
        000       & X X       & OP\_TF       & X X X X X X X X X      & COND       & DESTINO \\ \hline
    \end{tabular}
    \caption{Tabela de Formato}
  \end{center}
\end{table}  
% fim

% inicio da tabela de operações das instruções de desvio
\FloatBarrier
\begin{table}[H]
  \begin{center}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{130pt}|>{\centering\arraybackslash}m{209pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{OP\_TF} & \cellcolor[gray]{0.9}\textbf{Mnemônico} & \cellcolor[gray]{0.9}\textbf{Operação} \\ \hline
        000      & jf.cond DESTINO            & Jump False \\ \hline
        001      & jt.cond DESTINO       & Jump True \\ \hline
        010      & j DESTINO       & Jump Incondicional \\ \hline
    \end{tabular}
    \caption{Tabela de Instruções de Desvio}
  \end{center}
\end{table}  
% fim

As instruções de desvio condicional devem testar as condições apresentadas no quadro abaixo:

% inicio da tabela de condições
\FloatBarrier
\begin{table}[H]
  \begin{center}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{130pt}|>{\centering\arraybackslash}m{189pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{COND} & \cellcolor[gray]{0.9}\textbf{Mnemônico} & \cellcolor[gray]{0.9}\textbf{Condição}  \\ \hline
        000         & true          & TRUE \\ \hline
        001         & neg           & Resultado da ALU negativo \\ \hline
        010         & zero          & Resultado da ALU zero \\ \hline
        100         & carry         & Carry da ALU \\ \hline
        101         & negzero       & Resultado da ALU negativo ou zero \\ \hline
        111         & overflow      & Resultado da ALU overflow \\ \hline
    \end{tabular}
    \caption{Tabela de Condições}
  \end{center}
\end{table}  

% fim
\newpage
\subsection{Instruções de Desvio por Registrador}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./pictures/DatapathDES_REG.pdf}
\caption{Datapath Desvio por Registrador}
\end{figure}
São duas as instruções de desvio por registrador, jump and link (jal) e jump register (jr). Na instrução de jump and link, o valor de PC+1 deve ser armazenado no registrador r15 (definido pelo compilador) e o conteúdo do registrador RB armazenado em PC. Já no caso da instrução jump register, a única operação a ser feita é passar o conteúdo do registrador RB para o PC.\newline

As instruções de desvio por registrador possuem o seguinte formato:

% inicio da tabela de formato de instruções de desvio por registrador
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.46}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{31pt}|>{\centering\arraybackslash}m{32pt}|>{\centering\arraybackslash}m{29pt}|>{\centering\arraybackslash}m{90pt}|>{\centering\arraybackslash}m{32pt}|>{\centering\arraybackslash}m{127pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{31:29} & \cellcolor[gray]{0.9}\textbf{28:27} & \cellcolor[gray]{0.9}\textbf{26:24} & \cellcolor[gray]{0.9}\textbf{23:16} & \cellcolor[gray]{0.9}\textbf{15:12} & \cellcolor[gray]{0.9}\textbf{11:0} \\ \hline
        1 1 0       & X X       & OP\_TF       & X X X X X X X X       & RB        & X X X X X X X X X X X X \\ \hline
    \end{tabular}
    \caption{Tabela de Formato}
  \end{center}
\end{table}  
% fim

% inicio da tabela 
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.46}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{89pt}|>{\centering\arraybackslash}m{150pt}|>{\centering\arraybackslash}m{150pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{OP\_TF} & \cellcolor[gray]{0.9}\textbf{Mnemônico} & \cellcolor[gray]{0.9}\textbf{Operação} \\ \hline
        011       & jal b         & Jump and Link \\ \hline
        100       & jr b          & Jump Register \\ \hline
    \end{tabular}
    \caption{Tabela de Instruções de Desvio por Registrador}
  \end{center}
\end{table}  
% fim

\subsection{HALT}
A instrução HALT representa uma parada no sistema. Nesta instrução é realizado um salto para o endereço atual.

O HALT possui o formato seguinte:

% inicio da tabela de formato do HALT
\FloatBarrier
\begin{table}[H]
  \begin{center}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{34pt}|>{\centering\arraybackslash}m{30pt}|>{\centering\arraybackslash}m{34pt}|>{\centering\arraybackslash}m{136pt}|>{\centering\arraybackslash}m{130pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{31:29} & \cellcolor[gray]{0.9}\textbf{28:27} & \cellcolor[gray]{0.9}\textbf{26:24} & \cellcolor[gray]{0.9}\textbf{23:12} & \cellcolor[gray]{0.9}\textbf{11:0}  \\ \hline
        1 0 1       & X X       & 010        & X X X X X X X X X X X X       & DESTINO ATUAL \\ \hline
    \end{tabular}
    \caption{Tabela de Formato}
  \end{center}
\end{table}  
% fim

% inicio da tabela de operação HALT
\FloatBarrier
\begin{table}[H]
  \begin{center}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{182pt}|>{\centering\arraybackslash}m{220pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Mnemônico} & \cellcolor[gray]{0.9}\textbf{Operação} \\ \hline
        L: j L      & PC = PC \\ \hline
    \end{tabular}
    \caption{Tabela de Instrução HALT}
  \end{center}
\end{table}  
% fim

\subsection{NOP}
Nessa instrução todos os sinais de controle são zerados, desta forma nada é registrado na memória ou no banco de registradores. A NOP é realizada executando um jump False com a condição TRUE para o endereço 0, resultando no seguinte formato:

% inicio da tabela de formato do NOP
\FloatBarrier
\begin{table}[H]
  \begin{center}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{37pt}|>{\centering\arraybackslash}m{365pt}|} \hline
    \cellcolor[gray]{0.9}\textbf{31:29} & \cellcolor[gray]{0.9}\textbf{28:0} \\ \hline
        0 0 0       &  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\ \hline
    \end{tabular}
    \caption{Tabela de Formato}
  \end{center}
\end{table}  
% fim

\newpage
\section{Descrição dos Componentes}
Durante algumas discussões foi decidido quais  componentes constituiriam o processador. A partir de análises das instruções foram listados os componentes apresentados nas subsessões a seguir:
\subsection{Contador de Programa (Program Counter)}
O Contador de Programa (PC) é o registrador que armazena o endereço da próxima instrução a ser executada. Ele é atualizado a cada borda ascendente de clock.
\begin{figure}[H]
\centering
\includegraphics[width=0.25\textwidth]{./pictures/PC.PNG}
\caption{Contador de Programa}
\end{figure}

% inicio da tabela
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.4}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{60pt}|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{182pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Nome} & 
      \cellcolor[gray]{0.9}\textbf{Tamanho} & 
      \cellcolor[gray]{0.9}\textbf{Direção} &
      \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
        in\_PC      & 32    & Entrada   & Endereço de destino do salto \\ \hline
        out\_PC     & 32    & Saída     & Saída do PC \\ \hline
        RST\_PC     & 1     & Entrada   & Sinal que limpa o pc\\ \hline
    \end{tabular}
    \caption{Tabela de Sinais do PC}
  \end{center}
\end{table}  
% fim

\subsection{Memória de Instruções}
Tem como funcionalidade armazenar todas as instruções do programa a ser executado. A leitura da instrução acontece sempre.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/IM.PNG}
\caption{Memória de Instruções}
\end{figure}

% inicio da tabela
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.4}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{60pt}|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{182pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Nome} & 
      \cellcolor[gray]{0.9}\textbf{Tamanho} & 
      \cellcolor[gray]{0.9}\textbf{Direção} &
      \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
       RI       & 32 & Entrada & Endereço da instrução a ser lida\\ \hline
       WI       & 32 & Entrada & Endereço de entrada na memória de instrução \\ \hline
       I        & 32 & Saída   & Instrução atual \\ \hline
       W\_IM    & 1 & Entrada  & Sinal que habilita a escrita \\ \hline
       RST\_IM  & 1 & Entrada  & Sinal que limpa a memória de instruções \\ \hline
       
    \end{tabular}
    \caption{Tabela de Sinais da Memória de Instruções}
  \end{center}
\end{table}  
% fim

\subsection{Banco de Registradores}
O banco de registradores consiste em um bloco formado por 16 registradores de propósito geral de 32 bits. Sua função é registrar os dados utilizado por um programa. A entrada que controla escrita é ligada ao clock do processador, e a cada borda descendente de clock, a escrita é realizada, caso o sinal W\_RB esteja em nível lógico alto.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/RB.PNG}
\caption{Banco de Registradores}
\end{figure}

% inicio da tabela
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.1}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{60pt}|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{182pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Nome} & 
      \cellcolor[gray]{0.9}\textbf{Tamanho} & 
      \cellcolor[gray]{0.9}\textbf{Direção} &
      \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
       RA     & 4   & Entrada   & Endereço do registrador A \\ \hline
       RB     & 4   & Entrada   & Endereço do registrador B \\ \hline
       WC     & 4   & Entrada   & Endereço de escrita para o registrador destino \\ \hline
       WPC    & 32  & Entrada   & Entrada do dado a ser armazenado no registrador destino \\ \hline
       PRA & 32 & Saída & Saída do registrador A \\ \hline
       PRB & 32 & Saída & Saída do registrador B \\ \hline
       W\_RB & 1 & Entrada & Sinal que habilita a escrita no banco de resgistradores \\ \hline
       RST\_RB  & 1 & Entrada  & Sinal que limpa a memória de instruções \\ \hline
    \end{tabular}
    \caption{Tabela de Sinais do Banco de Registradores}
  \end{center}
\end{table}  
% fim

\subsection{Extensor de Sinal}
O extensor de sinal é utilizado para estender o sinal dos bits de entrada nas operações com constantes e operações de desvio, afim de padronizar os dados que são operados em 32 bits.
\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/SE.PNG}
\caption{Extensor de Sinais}
\end{figure}
% inicio da tabela
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.1}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{60pt}|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{182pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Nome} & 
      \cellcolor[gray]{0.9}\textbf{Tamanho} & 
      \cellcolor[gray]{0.9}\textbf{Direção} &
      \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
       InSE & 12/16 &  Entrada  & Constante a ser extendida \\ \hline
       OutSE & 32 &  Saída  & Constante extendida \\ \hline
       OP\_SE & 1  &  Entrada  & Sinal de controle do extensor \\ \hline
    \end{tabular}
    \caption{Tabela de Sinais do Extensor de Sinais}
  \end{center}
\end{table}  
% fim
\subsection{Unidade Lógica e Aritmética (Arithmetic Logic Unit)}
A ALU é um circuito combinacional responsável por realizar operações aritméticas e lógicas dentro do processador. As operações a serem executadas são determinadas por meio dos sinais de controle e das suas entradas de operação, logo após os dados de entrada são computados e o resultado é obtido na saída do circuito. Além disso é computado as flags utilizada nas comparações das condições de salto junto ao módulo testador de flags.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/ALU.PNG}
\caption{Unidade Lógica Aritmética}
\end{figure}


% inicio da tabela
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.4}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{60pt}|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{182pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Nome} & 
      \cellcolor[gray]{0.9}\textbf{Tamanho} & 
      \cellcolor[gray]{0.9}\textbf{Direção} &
      \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
        A       &   32 & Entrada   & Operando A \\ \hline
        B       &   32 & Entrada   & Operando B \\ \hline
        C       &   32 & Saída     & Resultado da operação \\ \hline
        F       &   4  & Saída     & Flags  \\ \hline
        OP\_ALU &   5  & Entrada   & Código de operação da instrução atual  \\ \hline
        W\_RF   &   3  & Entrada   & Define quais flags serão armazenadas  \\ \hline
    \end{tabular}
    \caption{Tabela de sinais da ALU}
  \end{center}
\end{table}  
% fim

\subsection{Memória de Dados (Data Memory)}
A Memória de dados tem como propósito salvar/ler dados proveniente das instruções de acesso à memória. A leitura dessa memoria funciona da mesma maneira que a Memória de Instrução.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/DM.PNG}
\caption{Memória de Dados}
\end{figure}

% inicio da tabela
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.15}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{60pt}|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{182pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Nome} & 
      \cellcolor[gray]{0.9}\textbf{Tamanho} & 
      \cellcolor[gray]{0.9}\textbf{Direção} &
      \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
       WP  & 32  & Entrada   & Dado as ser armazenado na memória \\ \hline
       AD  & 32  & Entrada   & Endereço para armazenamento \\ \hline
       PR  & 32  & Saída     & Dado lido da memória de dados \\ \hline
       W\_DM & 1 & Entrada   & Sinal de escrita na memória de dados \\ \hline
       RST\_DM & 1 & Entrada   & Sinal que limpa a memória de dados \\ \hline
    \end{tabular}
    \caption{Tabela de Sinais da Memória de Dados}
  \end{center}
\end{table}  
% fim

\subsection{Gerador de Sinais}
Responsável por gerar todos sinais de controle necessários para executar a instrução atual. Esses sinais são responsável por definir o fluxo dos dados por todo o processador, garantindo que a instrução atual não acesse módulos não desejados.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/SG.PNG}
\caption{Gerador de Sinais}
\end{figure}

% inicio da tabela
\begin{center}
\begin{longtable}[pos]{|m{50pt}|m{60pt}|m{70pt}|m{182pt}| } \hline
	\cellcolor[gray]{0.9} \textbf{Nome} \centering &
	\cellcolor[gray]{0.9} \textbf{Tamanho} \centering &
	\cellcolor[gray]{0.9} \textbf{Direção} \centering  &
	\cellcolor[gray]{0.9} \textbf{Descrição} \\ \hline \endfirsthead \hline
	\multicolumn{4}{|c|}{{\bfseries \textbf{continuação da tabela anterior}}} \\ \hline
	\cellcolor[gray]{0.9} \textbf{Nome} \centering  &
	\cellcolor[gray]{0.9} \textbf{Tamanho} \centering  &
	\cellcolor[gray]{0.9} \textbf{Direção} \centering  &
	\cellcolor[gray]{0.9} \textbf{Descrição} \\ \hline \endhead
	\multicolumn{4}{|c|}{{\textbf{continua na próxima página}}} \\ \hline \endfoot
	\hline \endlastfoot

        I       \centering &   8   \centering & Entrada \centering & Define qual tipo de instrução \\ \hline
        OP\_SE  \centering &   1   \centering & Saída   \centering & Código de operação que indica qual extensão ira ser realizada\\ \hline
        OP\_FU  \centering &   2   \centering & Saída   \centering & Sinal que define se é necessário utilizar o adiantamento de dados para o operador A ou B das operações da ALU e memória\\ \hline
        S\_MXSE \centering &   1   \centering & Saída   \centering & Seletor do multiplexador (mx\_b) que seleciona a origem do operador B das operações da ALU e memória\\ \hline
        OP\_ALU \centering &   5   \centering & Saída   \centering & Código da operação a ser realizada na ALU \\ \hline
        W\_RF   \centering &   1   \centering & Saída   \centering & Sinal que define quais flags serão armazenadas  \\ \hline
        W\_DM   \centering &   1   \centering & Saída   \centering & Sinal que indica uma escrita na Memória de Dados  \\ \hline
        S\_MXRB \centering &   2   \centering & Saída   \centering & Seletor do multiplexador do RB que indica qual a origem do dado a ser armazenado\\ \hline
        OP\_TF  \centering &   3   \centering & Saída   \centering & Sinal que indica qual é o tipo de comparação será feita para condição de pulo\\ \hline

\caption{Tabela de Sinais do Gerador de Sinais}
\end{longtable}
\end{center}



\subsection{Unidade de Encaminhamento}
Responsável por adiantar dados necessários para a operação atual, porém ainda não salvos no banco de registradores, evitando assim o conflito de dados. Este módulo verifica se:
    \begin{itemize}  
        \item é necessário checar o adiantamento de dados (através do sinal OP\_FU. Sendo que 00 ele não realiza a checagem, 01 verifica apenas RB, 10 apenas RA e 11 verifica os dois endereços;
        \item a operação anterior escreverá no banco de registradores (através do sinal W\_RB);
        \item o registrador indicado por WC (da instrução anterior) é igual a RA, ou RB.
    \end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/FU.PNG}
\caption{Unidade de Encaminhamento}
\end{figure}

% inicio da tabela
\begin{center}
\begin{longtable}[pos]{|m{50pt}|m{60pt}|m{70pt}|m{182pt}| } \hline
	\cellcolor[gray]{0.9} \textbf{Nome} \centering &
	\cellcolor[gray]{0.9} \textbf{Tamanho} \centering &
	\cellcolor[gray]{0.9} \textbf{Direção} \centering  &
	\cellcolor[gray]{0.9} \textbf{Descrição} \\ \hline \endfirsthead \hline
	\multicolumn{4}{|c|}{{\bfseries \textbf{continuação da tabela anterior}}} \\ \hline
	\cellcolor[gray]{0.9} \textbf{Nome} \centering  &
	\cellcolor[gray]{0.9} \textbf{Tamanho} \centering  &
	\cellcolor[gray]{0.9} \textbf{Direção} \centering  &
	\cellcolor[gray]{0.9} \textbf{Descrição} \\ \hline \endhead
	\multicolumn{4}{|c|}{{\textbf{continua na próxima página}}} \\ \hline \endfoot
	\hline \endlastfoot

        RA    \centering &   4   \centering & Entrada \centering & Registrador A da instrução atual\\ \hline
        RB    \centering &   4   \centering & Entrada \centering & Registrador B da instrução atual\\ \hline
        WC    \centering &   4   \centering & Entrada \centering & Endereço a ser escrito da instrução anterior\\ \hline
        OP\_FU \centering &   2  \centering & Entrada \centering & Sinal que define se é necessário verificar o operador A, ou o operador B\\ \hline
        W\_RB \centering &   1   \centering & Entrada \centering & Sinal da instrução anterior que indica se ela escreverá no banco de registradores \\ \hline
        fa    \centering &   1   \centering & Saída   \centering & Sinal que indica o adiantamento do operador A \\ \hline
        fb    \centering &   1   \centering & Saída  \centering  & Sinal que indica o adiantamento do operador B \\ \hline

\caption{Tabela de Sinais da Unidade de Encaminhamento}
\end{longtable}
\end{center}

\subsection{Testador de Flags}
Esse módulo combinacional foi criado com o objetivo de decidir se um jump será ou não realizado conforme a condição (COND) é o sinal vindo da unidade de controle. A partir do sinal COND, este módulo decide se o teste será feito utilizando a flag O(111), S(001), C(100), Z(010), S | Z(101), ou ainda, se o teste será feito com a condição true(000). A saída deste módulo é ligada diretamente ao multiplexador do pc, que seleciona se o próximo valor do PC virá do extensor de sinal (saída 00 do testador, indicando que um desvio por endereço de memória), do banco de registradores (saída 01 do testador, indicando um desvio por registrador) ou ainda, do somador do PC (saída 10 do testador, indicando que deve seguir o fluxo normal de execução).

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{./pictures/TF.PNG}
\caption{Testador de Flags}
\end{figure}
% inicio da tabela
\FloatBarrier
\begin{table}[H]
  \begin{center}
  \renewcommand{\arraystretch}{1.5}
    \begin{tabular}[pos]{|>{\centering\arraybackslash}m{50pt}|>{\centering\arraybackslash}m{60pt}|>{\centering\arraybackslash}m{70pt}|>{\centering\arraybackslash}m{182pt}|} \hline
      \cellcolor[gray]{0.9}\textbf{Nome} & 
      \cellcolor[gray]{0.9}\textbf{Tamanho} & 
      \cellcolor[gray]{0.9}\textbf{Direção} &
      \cellcolor[gray]{0.9}\textbf{Descrição} \\ \hline
       O    &   1   & Entrada & Flag de overflow a ser testada \\ \hline
        S    &   1   & Entrada & Flag de sinal a ser testada\\ \hline
        C    &   1   & Entrada & Flag de carry a ser testada\\ \hline
        Z    &   1   & Entrada & Flag de zero a ser testada \\ \hline
        COND &   3   & Entrada &Condição que será testada \\ \hline
        S\_MXPC  &   1   & Saída & Sinal que indica se o salto será ou não realizado \\
        \hline
        OP\_TF & 3  &  Entrada  & Sinal de controle do testador de flags \\ \hline
    \end{tabular}
    \caption{Tabela de Sinais do Testador de Flags}
  \end{center}
\end{table}  
% fim
\newpage
\section{Assembly}
Para a codificação dos programas deve ser utilizada a linguagem Assembly. Através dos mnemônicos já descritos anteriormente, serão escritas as instruções a serem executadas. Em seguida, através de um programa montador, o código fonte do programa será traduzido em linguagem de máquina para um arquivo binário que poderá ser entendido pelo processador e executado.\newline

Além das instruções, o código fonte deve/pode conter algumas diretivas importantes, são elas:

\begin{itemize}
\item \textbf .module NOME - Indica o início do programa com o nome informado;
\item \textbf .pseg - Indica o segmento de programa, ou seja, a partir desse ponto devem conter as instruções a serem executadas. Esta diretiva é encerrada após a ocorrência de uma das diretivas seguintes;
\item \textbf .dseg - Indica o segmento de dados que deve ser usado para declaração de variáveis globais. Esta diretiva não é obrigatória.
\item \textbf .end - Indica ao montador o fim do programa. Assim, qualquer instrução subsequente será desconsiderada.
\end{itemize}

A qualquer momento no código podem ser inseridos comentários. Para isto deve-se inserir o caractere ";" (ponto e vírgula), indicando que a partir dalí todo o restante da linha é comentário e será desconsiderado pelo montador.

Outro ponto importante a ser ressaltado é os labels, usados para indicar um destino de desvios ou uma nova variável. Estes labels devem conter apenas caracteres alfanuméricos. E, para os labels de desvios, devem estar na mesma linha da próxima instrução, para que esta, possa ser interpretada pelo montador.

\end{document}
